#pragma kernel SwarmMain
#include "SimplexNoise3D.hlsl"

struct Swarmer {
    float3 position;	// = 12
	float3 velocity;	// = 12
    float life;			// = 4
};

struct SwarmTarget {
    float3 position;
    float hp;
};

struct WorldNode {
	float3 position;	// = 12
	float occupied;		// = 4
};

RWStructuredBuffer<Swarmer> swarmers;
RWStructuredBuffer<SwarmTarget> targets;
RWStructuredBuffer<WorldNode> world;
float3 hivePosition;
float swarmerVelocity;
float deltaTime;
int width;
int height;
int depth;
float curlE;
float dir;

uint rng_state;
uint rand_xorshift()
{
	rng_state ^= (rng_state << 13);
	rng_state ^= (rng_state >> 17);
	rng_state ^= (rng_state << 5);
	return rng_state;
}

uint wang_hash(uint seed)
{
	seed = (seed ^ 61) ^ (seed >> 16);
	seed *= 9;
	seed = seed ^ (seed >> 4);
	seed *= 0x27d4eb2d;
	seed = seed ^ (seed >> 15);
	return seed;
}

float3 snoiseVec3(float3 x)
{

	float s = snoise(x);
	float s1 = snoise(float3(x.y - 19.1, x.z + 33.4, x.x + 47.2));
	float s2 = snoise(float3(x.z + 74.2, x.x - 124.5, x.y + 99.4));
	float3 c = float3(s, s1, s2);
	return c;
}


float3 curlNoise(float3 p, float E)
{

	float e = E;
	float3 dx = float3(e, 0.0, 0.0);
	float3 dy = float3(0.0, e, 0.0);
	float3 dz = float3(0.0, 0.0, e);

	float3 p_x0 = snoiseVec3(p - dx);
	float3 p_x1 = snoiseVec3(p + dx);
	float3 p_y0 = snoiseVec3(p - dy);
	float3 p_y1 = snoiseVec3(p + dy);
	float3 p_z0 = snoiseVec3(p - dz);
	float3 p_z1 = snoiseVec3(p + dz);

	float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;
	float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;
	float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;

	const float divisor = 1.0 / (2.0 * e);
	return normalize(float3(x, y, z) * divisor);

}


/*
    Create a position for the hive.

    Create a buffer with entitites.
    
    Create a buffer with targets (containing direction).

    Create a 3D buffer for path tracers.

    ------------

    Update the position of the swarmers each frame. 

        Set a weak path tracer in the 3D buffer.

    Sample the 3D buffer with path tracers around the current node.

        if a weak tracer is found. modify the direction slightly towards that node.

        if a strong tracer is found. modify the direction strongly towards that node. 

    If a target is found.
        
        set a state in the entity (collected = true etc)

        make the entity move back towards the hive via the path tracers (opposire direction of which they are poitning).

    If collected && position == hive.position

        collected = false

    Entities have a timer. If that timer reaches 0 it will return to the hive regardless.
        
        during retreat, they will not place pathtracers.

*/
float3 RandomDirection(int seed) {
	rng_state = seed;
	float r0 = float(rand_xorshift()) * (1.0 / 4294967296.0) * 2 - 1;
	float r1 = float(rand_xorshift()) * (1.0 / 4294967296.0) * 2 - 1;
	float r2 = float(rand_xorshift()) * (1.0 / 4294967296.0) * 2 - 1;
	return normalize(float3(r0, r1, r2));
}

[numthreads(10,10,10)]
void SwarmMain (uint3 id : SV_DispatchThreadID)
{
    // Flat[x + WIDTH * (y + DEPTH * z)] = Original[x, y, z]
	// Flat[x + WIDTH * (y + HEIGHT * z)] = Original[x, y, z]

	// Each thread will work on one swarmer.
	

	float nodeSize = 0.5;
	int sampleIndex = id.x + width * (id.y + height * id.z);

	
	Swarmer swarmer = swarmers[sampleIndex];
	//swarmer.velocity = normalize(float3(id.x, id.y, id.z));
	swarmer.life += deltaTime;
	//swarmer.position += swarmer.velocity * deltaTime * sin(swarmer.life);
	swarmer.position += curlNoise(swarmer.position, curlE) * deltaTime * dir;// *saturate(sin(life * 100));

	/*
	if (swarmer.life <= 0)
	{
		swarmer.position = hivePosition + RandomDirection(sampleIndex)/ 10;
		swarmer.life = 3;
	}*/

	swarmers[sampleIndex] = swarmer;


	world[sampleIndex].position = float3(id.x, id.y, id.z);
	world[sampleIndex].occupied = 0;
}
