#pragma kernel SwarmMain
struct Swarmer {
    float3 position;	// = 12
	float3 direction;	// = 12
    float life;			// = 4
	float startDelay;	// = 4
	float3 color;		// = 12
};

struct SwarmTarget {
    float3 position;
    float hp;
};

RWStructuredBuffer<Swarmer> swarmers;
RWStructuredBuffer<SwarmTarget> targets;
RWTexture3D<float4> worldTex;
float hiveX;
float hiveY;
float hiveZ;
float swarmerVelocity;
float deltaTime;
float elapsedTime;
int width;
int height;
int depth;
float curlE;
float dir;
float traceAdd;
float traceDecay;
float traceAttraction;
float swarmerSpeed;


uint rng_state;
uint rand_xorshift()
{
	rng_state ^= (rng_state << 13);
	rng_state ^= (rng_state >> 17);
	rng_state ^= (rng_state << 5);
	return rng_state;
}

uint wang_hash(uint seed)
{
	seed = (seed ^ 61) ^ (seed >> 16);
	seed *= 9;
	seed = seed ^ (seed >> 4);
	seed *= 0x27d4eb2d;
	seed = seed ^ (seed >> 15);
	return seed;
}

float3 RandomDirection(int seed) {
	rng_state = seed;
	float r0 = float(rand_xorshift()) * (1.0 / 4294967296.0) * 2 - 1;
	float r1 = float(rand_xorshift()) * (1.0 / 4294967296.0) * 2 - 1;
	float r2 = float(rand_xorshift()) * (1.0 / 4294967296.0) * 2 - 1;
	return normalize(float3(r0, r1, r2));
}


[numthreads(10,10,10)]
void SwarmMain (uint3 id : SV_DispatchThreadID)
{
	int sampleIndex = id.x + width * (id.y + height * id.z);
	
	// Decay the trace
	worldTex[id.xyz] = float4(max(0, worldTex[id.xyz].x - traceDecay), 0,0,0);
	
	// Get the swarmer from the buffer
	Swarmer swarmer = swarmers[sampleIndex];
	swarmer.life -= deltaTime;
	swarmer.position += swarmer.direction * deltaTime * swarmerSpeed;
	
	// Check if inside bounds
	bool insideWidth = swarmer.position.x >= 0 && swarmer.position.x <= 100;
	bool insideHeight = swarmer.position.y >= 0 && swarmer.position.y <= 100;
	bool insideDepth = swarmer.position.z >= 0 && swarmer.position.z <= 100;

	if (!insideWidth || !insideHeight || !insideDepth)
	{
		swarmer.direction = normalize(normalize(float3(hiveX, hiveY, hiveZ) - swarmer.position) + RandomDirection(sampleIndex) * 0.6);
	}

	// Get the swarmer world coord
	uint3 swarmerWorldCoord = uint3(swarmer.position.x, swarmer.position.y, swarmer.position.z);

	// Add trace from the swarmer
	worldTex[swarmerWorldCoord] = float4(min(worldTex[swarmerWorldCoord].x + traceAdd, 1), 0,0,0);


	float highestTrace = 0;
	uint3 bestNeightbour;
	float3 bestDirection = swarmer.direction;
	float3 color = float3(1, 0, 0);

	for (int x = -1; x <= 1; x++)
	{
		for (int y = -1; y <= 1; y++)
		{
			for (int z = -1; z <= 1; z++)
			{
				uint3 neightbourSampleIndex = uint3(swarmer.position.x + x, swarmer.position.y + y, swarmer.position.z + z);
				//WorldNode wn = world[neightbourSampleIndex];
				float trace = worldTex[neightbourSampleIndex].x;
				bool isMyPos = x == int(swarmer.position.x) && y == int(swarmer.position.y) && z == int(swarmer.position.z);
				if (trace > highestTrace && !isMyPos)
				{
					highestTrace = trace;
					bestNeightbour = neightbourSampleIndex;
					bestDirection = worldTex[neightbourSampleIndex].xyz - swarmer.position;
					color = float3(0, highestTrace, 0); //float3(float(bestNeightbour.x) / 100, float(bestNeightbour.y) / 100, float(bestNeightbour.z) / 100);
				}
			}
		}
	}

	swarmer.direction = normalize(lerp(swarmer.direction, normalize(bestDirection), traceAttraction));
	swarmer.color = color;

	swarmers[sampleIndex] = swarmer;

}
